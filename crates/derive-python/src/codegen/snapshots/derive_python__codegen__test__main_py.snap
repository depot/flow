---
source: crates/derive-python/src/codegen/mod.rs
expression: output
---
import asyncio
import sys
import typing

from patterns.sums import (Request, Response)
from my_module import Derivation


async def stdin_requests() -> typing.AsyncGenerator[Request, None]:
    loop = asyncio.get_event_loop()
    reader = asyncio.StreamReader(limit=1 << 27)  # 128 MiB.
    protocol = asyncio.StreamReaderProtocol(reader)
    await loop.connect_read_pipe(lambda: protocol, sys.stdin)

    while line := await reader.readline():
        yield Request.model_validate_json(line)


async def main() -> None:
    """Main event loop for Python derivation runtime."""

    requests = stdin_requests()
    open = await requests.__anext__()

    if not open.open:
        print("Error: Expected open message", file=sys.stderr)
        sys.exit(1)

    # Instantiate user's Derivation class
    derivation = Derivation(open.open)

    # Build array of transform methods
    transforms = [derivation.from_ints, derivation.process_strings]

    # Emit opened response
    print(Response(opened=Response.Opened()).model_dump_json(by_alias=True), flush=True)

    # Main protocol loop
    async for request in requests:
        if request.read:
            async for doc in transforms[request.read.transform](request.read):
                response = Response(published=Response.Published(doc=doc))
                print(response.model_dump_json(by_alias=True), flush=False)

        elif request.flush:
            async for doc in derivation.flush():
                response = Response(published=Response.Published(doc=doc))
                print(response.model_dump_json(by_alias=True), flush=False)

            print(Response(flushed=Response.Flushed()).model_dump_json(by_alias=True), flush=True)

        elif request.start_commit:
            started_commit = derivation.start_commit(request.start_commit)
            response = Response(startedCommit=started_commit)
            print(response.model_dump_json(by_alias=True), flush=True)

        elif request.reset:
            await derivation.reset()

        else:
            raise RuntimeError(f"Unknown message: {request}")


if __name__ == "__main__":
    try:
        asyncio.run(main())
    except Exception as e:
        print(f"Fatal error: {e}", file=sys.stderr)
        import traceback

        traceback.print_exc()
        sys.exit(1)
